
--- This file is almost the same as the one in dynamics-concrete.maude, except that 
---  1) physicalActions do not have timers 
---  3) an extra object for (global) symbolic constraints


omod TIME-BOUNDED-EVENT-CHECK is
  protecting EVENT-QUEUE .
  protecting REACTION .
  protecting CLOCK .

  --- clock is reset when the event is first added to the queue
  class EventMonitor | event : ReactionIdSet, 
                       evalue : Value,
                       econst : BoolValue .
  subclass EventMonitor < Clock .

  var EM : Oid .
  var REACTORID : ReactorId .
  var ACTIONID : ActionId .
  var EVENTS : Events .
  var TAG : Tag .
  var QUEUE : EQueue .
  var V : Value .
  var BV : BoolValue .

  --- reset clock when EVENT are in the queue
  op check : Object EQueue -> Object .
  eq check(< EM : EventMonitor | clock : INF, event : REACTORID . ACTIONID >, 
           (event(REACTORID, ACTIONID, V, BV) EVENTS at TAG) ;; QUEUE)
   = < EM : EventMonitor | clock : zero , evalue : V, econst : BV > .
  eq check(< EM : EventMonitor | >, QUEUE) = < EM : EventMonitor | > [owise] .
endom


omod DYNAMICS-WITHOUT-TICK is
  including ABS-DYNAMICS-WITHOUT-TICK .
  including EXECUTE-STEP .
  including EVENT-QUEUE .
  including PHYSICAL-ACTIONS .
  including TIME-BOUNDED-EVENT-CHECK .

  --- At the moment, the global state is
  --- < env : Environment | physicalActions : ... >
  --- REACTORS and CONNECTIONS in some state
  --- < q : EventQueue | queue : ... >
  --- < sym : SymInfra | constraint : ..., counter : ... >
  --- < em : EventMonitor | clock : ..., event : ... >

  class SymInfra | constraint : BoolValue,
                   counter : Nat .


  vars REACTORS-AND-CONNECTIONS NEW-NETWORK : Configuration .
  vars QUEUE NEW-QUEUE : EQueue .
  vars E Q EM RXNS SYM : Oid .
  var INVOKED : ReactionIdSet .
  var EVENT : Event .
  var EVENTS : Events .
  vars CONST CONST' CONST'' : BoolValue .
  var TAG : Tag .
  var TI : TimeInf .
  vars T T' : Time .
  var N N' : Nat .


  --- In the symbolic setting, physical envs have no timer. Also,
  --- executeStep is non-deterministic.
  crl [step] :
      {< E : Environment | >
       REACTORS-AND-CONNECTIONS
       < Q : EventQueue | queue : (EVENTS at tag(T,N)) ;; QUEUE >
       < SYM : SymInfra | constraint : CONST >
       < RXNS : Invoked | >
       < EM : EventMonitor | >} 
    =>
      {< E : Environment | >
       NEW-NETWORK
       < Q : EventQueue | queue : NEW-QUEUE >
       < SYM : SymInfra | constraint : CONST' && CONST'' >
       < RXNS : Invoked | reactions : INVOKED >
       check(< EM : EventMonitor | >, NEW-QUEUE)} 
   if CONST' := CONST && [minConst(tag(T,N),QUEUE) and T equals zero]
   /\ smtCheck(CONST')
   /\ executeStep(EVENTS, REACTORS-AND-CONNECTIONS, QUEUE, trueVal)
      => networkQueueRxns(NEW-NETWORK, NEW-QUEUE, INVOKED, CONST'') 
   /\ smtCheck(CONST' && CONST'') .

  op minConst : Tag EQueue ~> Bool .
  eq minConst(tag(T,N), (EVENTS at tag(T',N')) ;; QUEUE)
   = ((T lt T') or ((T equals T') and N <= N')) and minConst(tag(T,N), QUEUE) .
  eq minConst(tag(T,N), empty) = true .

  
endom


*** Now we describe tick rules for symbolic analysis. 

omod SYM-REACH-DYNAMICS is
  including DYNAMICS-WITHOUT-TICK .

  vars REACTORS-AND-CONNECTIONS CONF : Configuration .
  vars CONST CONST' : BoolValue .
  vars T T' T0 : Time .
  var TI : TimeInf .
  vars E Q PA SYM RXNS EM : Oid .
  var N : Nat .
  var EVENTS : Events .
  vars QUEUE NEW-QUEUE : EQueue .
  var NZN : NzNat .
  var REACTORID : ReactorId .
  var TIMERID : TimerId .

  op timeBound : -> Time .   *** initialized by user


  --- A tick rule for non-physical events. This rule advances time
  --- until the first queue item is ready to execute.  Note that time 
  --- values in the event queue may be symbolic
   crl [tick] :
       {< E : Environment | physicalActions : CONF >
        REACTORS-AND-CONNECTIONS
        < Q : EventQueue | queue : (EVENTS at tag(T,N)) ;; QUEUE >
        < SYM : SymInfra | constraint : CONST >
        < RXNS : Invoked | >
        < EM : EventMonitor | >} 
       in time T0
    =>
       {< E : Environment | physicalActions : increaseClock(CONF, T) >
        REACTORS-AND-CONNECTIONS
        < Q : EventQueue | queue : (EVENTS at tag(zero,N)) ;; 
                                   decreaseTags(QUEUE,T) >
        < SYM : SymInfra | constraint : CONST' >
        < RXNS : Invoked | reactions : none >
        increaseClock(< EM : EventMonitor | >, T)} 
       in time (T0 plus T)
    if CONST' := CONST && [minConst(tag(T,N),QUEUE) and T ge zero and T0 plus T le timeBound] 
    /\ smtCheck(CONST') .

    op tv : Nat -> SMTVarId . --- SMT variable ids for time

    --- A tick rule for physical events. This rule advances time
    --- and ``fires'' a single physical event. 
    crl [extraTickRuleForPhysActs] :
       {< E : Environment | physicalActions : CONF >
        REACTORS-AND-CONNECTIONS
        < Q : EventQueue | queue : QUEUE >
        < SYM : SymInfra | constraint : CONST, counter : N >
        < RXNS : Invoked | >
        < EM : EventMonitor | >} 
       in time T0
     =>
       {envFire(< E : Environment | 
                    physicalActions : increaseClock(CONF, T) >)
        REACTORS-AND-CONNECTIONS
        < Q : EventQueue | queue : decreaseTags(QUEUE,T) >
        < SYM : SymInfra | constraint : CONST', counter : s N >
        < RXNS : Invoked | reactions : none >
        increaseClock(< EM : EventMonitor | >, T)} 
     in time (T0 plus T)
     if T := r(tv(N))    --- a fresh variable
     /\ CONST' := CONST && [minConst(tag(T,0),QUEUE) and T ge zero and T0 plus T le timeBound]
     /\ smtCheck(CONST') .

  --- TODO: the condition "T gt zero" may generate a deadlock state. 
  ---   Need to check whether it is OK or a bug. This seems a bug...

  --- Assume that T <= T' for any T'.
  op decreaseTags : EQueue Time -> EQueue .
  eq decreaseTags(empty, T) = empty .
  eq decreaseTags((EVENTS at tag(T', N)) ;; QUEUE, T) =
     (EVENTS at tag(T' monus T, N)) ;; decreaseTags(QUEUE, T) .
endom

