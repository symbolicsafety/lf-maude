--- First attempt at the overall dynamics of our interpreter.

in executeStep.maude

omod DYNAMICS is
  including EXECUTE-STEP .
  including TIMED-PRELUDE .

  subsort Configuration < System .

  --- At the moment, the global state is
  --- < env : Environment | physicalActions : ... >
  --- REACTORS and CONNECTIONS in some state
  --- < q : EventQueue | queue : ... >


  vars REACTORS-AND-CONNECTIONS CONF1 CONF
       PHYSICAL-ACTIONS NEW-NETWORK TIMERS : Configuration .
  var TI : TimeInf .
  vars T1 T T2 : Time .
  vars E Q PA : Oid .
  var N : Nat .
  var EVENTS : Events .
  vars QUEUE NEW-QUEUE : EQueue .
  var NZN : NzNat .
  var REACTORID : ReactorId .
  var TIMERID : TimerId .
  var VAL : Value .
  var ACTIONID : ActionId .
 

  *** We need some initialization, obviously.  TODO


  *** We have some freedom here; IF an event can happen
  *** at the same time when a physical action could happen, we always
  *** make the physical action happen first.
  ---  In reality physical actions and events probably
  ---  will never happen at the same time.
  

 crl [tick] :
     {< E : Environment | physicalActions : CONF1 >
      REACTORS-AND-CONNECTIONS
      < Q : EventQueue | queue : (EVENTS at tag(T1, N)) :: QUEUE >}
     =>
     {< E : Environment | physicalActions : decreaseTimers(CONF1, T) >
      REACTORS-AND-CONNECTIONS
      < Q : EventQueue | queue : (EVENTS at tag(T1 monus T, N))
                                 :: decreaseTags(QUEUE, T) >}
     in time T
     if T := min(T1, smallestTimer(CONF1))
        /\ T > 0 .


  op decreaseTimers : Configuration Time -> Configuration .
  *** decrease timers in out physical action objects:

  eq decreaseTimers(none, T) = none .
  eq decreaseTimers(< PA : PhysAct | leftOfPeriod : TI >   PHYSICAL-ACTIONS, T)
  = < PA : PhysAct | leftOfPeriod : TI monus T >   decreaseTimers(PHYSICAL-ACTIONS, T) .


  op decreaseTags : EQueue Time -> EQueue .
  eq decreaseTags(empty, T) = empty .
  eq decreaseTags((EVENTS at tag(T2, N)) :: QUEUE, T) =
     (EVENTS at tag(T2 monus T, N)) :: decreaseTags(QUEUE, T) .

  op smallestTimer : Configuration -> TimeInf .
  eq smallestTimer(none) = INF .
  eq smallestTimer(< PA : PhysAct | leftOfPeriod : TI >   PHYSICAL-ACTIONS)
   = min(TI, smallestTimer(PHYSICAL-ACTIONS)) .



 crl [tickMicro] :
     {< E : Environment | physicalActions : CONF1 >
      REACTORS-AND-CONNECTIONS
      < Q : EventQueue | queue : (EVENTS at tag(0, NZN)) :: QUEUE >}
     =>
     {< E : Environment | >
      REACTORS-AND-CONNECTIONS
      < Q : EventQueue | queue : (EVENTS at tag(0, 0)) :: QUEUE >} 
     if smallestTimer(CONF1) > 0 .
   --- condition ensures no mess/nondet between generating
   --- physical actions and reducing????
   --- CORRECT????




  crl [step] :
      {< E : Environment | physicalActions : CONF1 >
       REACTORS-AND-CONNECTIONS
       < Q : EventQueue | queue : (EVENTS at tag(0, 0)) :: QUEUE >} 
    =>
      {< E : Environment | physicalActions : CONF1 >
       NEW-NETWORK
       < Q : EventQueue | queue : NEW-QUEUE >} 
     --- NOTE: this could also generate future events that need to be inserted
     ---        into the event queue
   if   smallestTimer(CONF1) > 0
      /\ networkQueue(NEW-NETWORK, NEW-QUEUE) :=
            executeStep(EVENTS, REACTORS-AND-CONNECTIONS, QUEUE) .

   *** Note: condition ensures that physical actions are generated
   ***       before events are processed.


   *** This ends "standard" Lingua Franca interpreter.
   ***    However, we also add the new infrastructure/way of
   ***    treating physical actions.  The "environment" could generate
   ***    new events in the future even when the event queue is empty.
   ***  Therefore, we need an additional tick rule for this case:

    crl [extraTickRuleForPhysActs] :
     {< E : Environment | physicalActions : CONF1 >
      REACTORS-AND-CONNECTIONS
      < Q : EventQueue | queue : empty >}
     =>
     {< E : Environment | physicalActions : decreaseTimers(CONF1, T) >
      REACTORS-AND-CONNECTIONS
      < Q : EventQueue | queue : empty >}
     in time T
     if T := smallestTimer(CONF1)
        /\ T > 0
	/\ CONF1 =/= none .      --- implied by typing of T
*** Note: this rule should not apply when we do not have
***    physical actions, since T cannot have the value INF.
***    So the last conjunct in condition not really needed.


  --- add initial timer values to event queue:
  op addInitialTimers : Configuration EQueue -> EQueue .

  eq addInitialTimers(< REACTORID : Reactor | timers : TIMERS
                                                       < TIMERID : Timer | offset : T > >
		      REACTORS-AND-CONNECTIONS, QUEUE)
   = addInitialTimers(< REACTORID : Reactor | timers : TIMERS >
		      REACTORS-AND-CONNECTIONS,
		      schedule(event(REACTORID, TIMERID, [0]), T, QUEUE)) .

  eq addInitialTimers(REACTORS-AND-CONNECTIONS, QUEUE) = QUEUE [owise] .




  op addStartup : ActionId Configuration EQueue -> EQueue .
  --- addStartup(startup, init, empty)

  eq addStartup(ACTIONID, < REACTORID : Reactor | actions : CONF
                                                  < ACTIONID : LogicalAction |
						       payload : VAL > >
                REACTORS-AND-CONNECTIONS, QUEUE)
   = addStartup(ACTIONID, < REACTORID : Reactor | actions : CONF >
            REACTORS-AND-CONNECTIONS, schedule(event(REACTORID, ACTIONID, VAL), 0, QUEUE)) .

  eq addStartup(ACTIONID, REACTORS-AND-CONNECTIONS, QUEUE) = QUEUE [owise] .
endom

