---(
 Extending BOOL, RAT and INT with SMT variables  of the form b(x), i(x)
 and r(x)
 
 BoolExpr (Bool extended with SMT variables) expressions can be checked for
 satisfiability using smtCheck that transforms a BoolExpr into a BoolExpression 

)---)


--- Identifiers for variables
fmod SMT-VAR-ID is
    sort SMTVarId .
    op errorID : -> SMTVarId . --- For meta-level operations 
endfm


fmod LF-SMT-INTERFACE is
  protecting LF-ABS-VALUE-TIME .
  protecting SMT-VAR-ID .

  --- to quickly check for obvious unsat for the symbolic case
  op checkNotFalse : BoolValue ~> Bool .
  eq checkNotFalse(BV:BoolValue) = not (BV:BoolValue == falseVal) .

  --- smt variables
  op bb : SMTVarId -> BoolValue [ctor] .
  op rr : SMTVarId -> RatValue [ctor] .
endfm


fmod ALT-BOOLEAN-EXPR is
  including SMT-VAR-ID .
  including BOOL .

  sort BoolExpr .
  subsort Bool < BoolExpr .
  
  sort BoolVar .
  subsort BoolVar < BoolExpr .
  op b : SMTVarId -> BoolVar [ctor] .

  op not_ : BoolExpr -> BoolExpr [ditto] .
  op _and_ : BoolExpr BoolExpr -> BoolExpr [ditto] .
  op _xor_ : BoolExpr BoolExpr -> BoolExpr [ditto] .
  op _or_ : BoolExpr BoolExpr -> BoolExpr [ditto] .
  op _implies_ : BoolExpr BoolExpr -> BoolExpr [ditto] .

  op _===_ : BoolExpr BoolExpr -> BoolExpr [comm prec 51] .
  op _=/==_ : BoolExpr BoolExpr -> BoolExpr [comm prec 51] .
  op _?_:_ : BoolExpr BoolExpr BoolExpr -> BoolExpr [gather (e e e) prec 71] .

  vars A B C : BoolExpr .

--- from BOOL-OPS
  eq true and A = A .
  eq false and A = false .
  eq A and A = A .
  eq false xor A = A .
  eq A xor A = false .

---(
  eq A and (B xor C) = A and B xor A and C .
  eq not A = A xor true .
  eq A or B = A and B xor A xor B .
  eq A implies B = not(A xor A and B) .
)---)

  eq true implies A  = A .
  eq false implies A = true .
  eq A implies true  = true .

--- some basic equations
  eq A === A = true .

  eq (true ===  false) = (false).Bool .
  eq (true =/== false) = (true).Bool .

  eq true  ? A : B = A .
  eq false ? A : B = B .
endfm


--- Integer expressions
fmod ALT-INTEGER-EXPR is
  protecting ALT-BOOLEAN-EXPR .
  including INT .

  sort IntExpr .
  subsort Int < IntExpr .

  sort IntVar .
  subsort IntVar < IntExpr .
  op i : SMTVarId -> IntVar [ctor] .

  op -_ : IntExpr -> IntExpr [ditto] .
  op _+_ : IntExpr IntExpr -> IntExpr [ditto] .
  op _*_ : IntExpr IntExpr -> IntExpr [ditto] .
  op _-_ : IntExpr IntExpr -> IntExpr [ditto] .

  op _<_ : IntExpr IntExpr -> BoolExpr [ditto] .
  op _<=_ : IntExpr IntExpr -> BoolExpr [ditto] .
  op _>_ : IntExpr IntExpr -> BoolExpr [ditto].
  op _>=_ : IntExpr IntExpr -> BoolExpr [ditto] .

  op _===_ : IntExpr IntExpr -> BoolExpr [comm prec 51] .
  op _=/==_ : IntExpr IntExpr -> BoolExpr [comm prec 51] .
  op _?_:_ : BoolExpr IntExpr IntExpr -> IntExpr [gather (e e e) prec 71] .

--- The following operators are currently not supported.
---( 
  op _div_ : IntExpr IntExpr -> IntExpr [gather (E e) prec 31] . 
  op _mod_ : IntExpr IntExpr -> IntExpr [gather (E e) prec 31] .
  op _divisible_ : IntExpr IntExpr -> BoolExpr [prec 51] .
)---)

  vars A B : IntExpr .
  vars I J : Int .

--- some basic equations
  --- eq A === A = true .
  --- eq A <= A = true .
  --- eq A >= A = true .

  eq (A ===  B) = A <= B and A >= B .
  eq (A =/== B) = A < B  or  A > B .

  eq true  ? A : B = A .
  eq false ? A : B = B .
endfm

--- Because RAT includes INT, ALT-REAL must include ALT-INTEGER.
fmod ALT-REAL-INTEGER-EXPR is
  including SMT-VAR-ID .
  protecting ALT-INTEGER-EXPR .
  including RAT .

  sort RExpr .
  subsort Rat < RExpr .
  subsort IntExpr < RExpr .

  sort RVar StRExpr .
  subsort RVar < StRExpr < RExpr .
  op r : SMTVarId -> RVar [ctor] .

  op -_ : RExpr -> RExpr [ditto] .
  op _+_ : RExpr RExpr -> RExpr [ditto] .
  op _*_ : RExpr RExpr -> RExpr [ditto] .
  op _-_ : RExpr RExpr -> RExpr [ditto] .
  op _/_ : RExpr RExpr -> RExpr [ditto] .

  op -_ : StRExpr -> StRExpr [ditto] .
  op _+_ : StRExpr RExpr -> StRExpr [ditto] .
  op _*_ : StRExpr RExpr -> StRExpr [ditto] .

  op _-_ : StRExpr RExpr -> StRExpr [ditto] .
  op _-_ : RExpr StRExpr -> StRExpr [ditto] .
  op _/_ : StRExpr RExpr -> StRExpr [ditto] .
  op _/_ : RExpr StRExpr -> StRExpr [ditto] .

  op _<_ : RExpr RExpr -> BoolExpr [ditto] .
  op _<=_ : RExpr RExpr -> BoolExpr [ditto] .
  op _>_ : RExpr RExpr -> BoolExpr [ditto] .
  op _>=_ : RExpr RExpr -> BoolExpr [ditto] .

  op _===_ : RExpr RExpr -> BoolExpr [comm prec 51] .
  op _=/==_ : RExpr RExpr -> BoolExpr [comm prec 51] .
  op _?_:_ : BoolExpr RExpr RExpr -> RExpr [gather (e e e) prec 71] .
  --- op _?_:_ : BoolExpr Int Int -> Int [ditto] .

  op toReal : IntExpr -> RExpr .
  op toInteger : RExpr -> IntExpr .
  op isInteger : RExpr -> BoolExpr .

  vars A B : RExpr .
  var I : Int .
  vars R S : Rat .

--- some basic equations
  --- eq A === A = true .
  --- eq A <= A = true .
  --- eq A >= A = true .
   eq (A ===  B) = A <= B and A >= B .
   eq (A =/== B) = A <  B  or A >  B .

  eq true  ? A : B = A .
  eq false ? A : B = B .

  eq 0 + A = A .

  eq toReal(I) = I .
  eq toInteger(R) = floor(R) .

  eq isInteger(I) = true .
  eq isInteger(R) = floor(R) === R .
endfm


--- from an old version of the HybridSynchAADL implementation
fmod META-SMT-CONSTANT-TRANS is
  protecting META-LEVEL .
  protecting CONVERSION .

  vars T T' : Term .

  sort Nat? .
  subsort Nat < Nat? .
  op error : -> Nat? [ctor] .

  op metaTrIntC : Term -> TermQid [memo] .
  eq metaTrIntC(T) = qid(string(downTerm(T,error),10) + ".Integer")  .

  op metaTrRatC : Term -> TermQid [memo] .
  eq metaTrRatC('_/_[T,T']) 
   = qid(string(downTerm(T,error),10) + "/" + string(downTerm(T',error),10) + ".Real") .

  eq metaTrRatC(T) = qid(string(downTerm(T,error),10) + "/1.Real") [owise] .
endfm


fmod ALT-SMT-CHECK is
  protecting REAL-INTEGER .
  protecting ALT-REAL-INTEGER-EXPR .
  protecting META-SMT-CONSTANT-TRANS * (op __ : NatList NatList -> NatList to _#_) . 

   var B           : Bool .
   var BE          : BoolExpr .
   var M           : Module .
   var C           : Constant .
   var V           : Variable .
   var Q           : Qid .
   vars T T'       : Term .
   var TY          : Type .
   var TL TAL TAL' : TermList .
   var NTL         : NeTermList .
   var ID          : SMTVarId .

   --- Satisfiability check 
   op smtCheck : BoolExpr -> Bool .
   eq smtCheck(BE) = metaCheck(['ALT-SMT-CHECK], replace-vars(upTerm(BE))) .

  --- Validity check 
  op validity : BoolExpr -> Bool .
  eq validity(BE) = smtCheck(not BE) == false .

   --- replacing b(id) to id:Boolean 
   op replace-vars : Term -> Term .
   op replace-vars-list : TermList -> Term .

   eq replace-vars(C) = C .
   eq replace-vars(V) = V .

   eq replace-vars('b[T]) = qid(varid2str(downTerm(T ,errorID))   + ":Boolean") .
   eq replace-vars('i[T]) = qid(varid2str(downTerm(T ,errorID))   + ":Integer") .
   eq replace-vars('r[T]) = qid(varid2str(downTerm(T ,errorID))   + ":Real") .

   eq replace-vars(Q[TL]) = Q[ replace-vars-list(TL) ] [owise] .

   eq replace-vars-list(empty) = empty .
   eq replace-vars-list( (T, TL) ) = replace-vars(T) , replace-vars-list(TL) .

  op varid2str : SMTVarId ~> String .
  eq varid2str(ID) = $varid2str(upTerm(ID)) .

  op $varid2str : Term ~> String .
  op $varid2str-L : TermList ~> String .
  eq $varid2str(C) = string(getName(C)) . 
  eq $varid2str(Q[TL]) = string(Q) + "_" + $varid2str-L(TL) . 
  eq $varid2str-L(empty) = "" .
  eq $varid2str-L( (T, TL)) = $varid2str(T) + "_" + $varid2str-L(TL) .
endfm
