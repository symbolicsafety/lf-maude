
omod EXECUTE-REACTION is
  including ABS-EXECUTE-REACTION .
  protecting LF-SMT-INTERFACE .

  var REACTOR : ReactorId .
  var TSTATUS : TriggerStatus .
  vars RB RB1 RB2 : ReactionBody .
  var OUTPUTS : Events .
  var QUEUE : EQueue .
  var VALUATION : ReactorState .
  vars ACTIONS INPORTS : Configuration .
  var BEXP : BoolExpr .
  vars BV CONST : BoolValue .

  --- the semantics of if-then-else-fi for the symbolic case
  crl executeReactionBody(
        < REACTOR : Reactor | state :  VALUATION,
                              inports : INPORTS, actions : ACTIONS >,
        (if BEXP then RB1 else RB2 fi) ; RB, OUTPUTS, QUEUE, TSTATUS, CONST)
   =>
      executeReactionBody(< REACTOR : Reactor | >,
        (RB1 ; RB),  
        OUTPUTS, QUEUE, TSTATUS, BV)
   if BV := eval(BEXP, VALUATION, INPORTS ACTIONS, TSTATUS) 
   /\ checkNotFalse(BV) .

  crl executeReactionBody(
        < REACTOR : Reactor | state :  VALUATION,
                              inports : INPORTS, actions : ACTIONS >,
        (if BEXP then RB1 else RB2 fi) ; RB, OUTPUTS, QUEUE, TSTATUS, CONST)
   =>
      executeReactionBody(< REACTOR : Reactor | >,
        (RB2 ; RB),  
        OUTPUTS, QUEUE, TSTATUS, BV) 
   if BV := ! eval(BEXP, VALUATION, INPORTS ACTIONS, TSTATUS)
   /\ checkNotFalse(BV) .
endom


omod EXECUTE-STEP is
  including EXECUTE-REACTION .
  including ABS-EXECUTE-STEP .

  vars REACTORID : ReactorId .
  vars PRE INVOKED : ReactionIdSet .
  vars OS TRIGGERIDS : OidSet .
  vars NETWORK GRAPH GRAPH' : Configuration .
  var OBJECT : Object .
  var TSTATUS : TriggerStatus .
  vars REACTIONS1 REACTIONS2 : ReactionList .
  var OUTPUTS : Events .
  vars QUEUE RESULT-QUEUE : EQueue .
  var RB : ReactionBody .
  var STATUS : ExecutionStatus .
  vars CONST CONST' : BoolValue .
  var N : Nat .

  --- In the symbolic setting, this is a rule with a rewrite condition,
  --- because executeReactionBody is nondeterministic.
  crl executeStep(
        < (REACTORID . N) : APGNode | 
            triggers : TSTATUS, status : present, pre : PRE > 
        GRAPH,
        NETWORK
        < REACTORID : Reactor | 
            reactions : REACTIONS1 (reaction N when TRIGGERIDS --> OS do {RB}) REACTIONS2 >,
        QUEUE,
        INVOKED, CONST)
   =>
      executeStep(
        < (REACTORID . N) : APGNode | status : executed >
        updateGraph(GRAPH, REACTORID, OS, NETWORK < REACTORID : Reactor | >, OUTPUTS),
        propagateImmediateOutputs(OUTPUTS, NETWORK OBJECT),    --- updated reactor
        scheduleDelayedInputs(OUTPUTS, NETWORK, RESULT-QUEUE),
        INVOKED ; (REACTORID . N), CONST && CONST')
   if presetOK(PRE, GRAPH)   
   /\ allTriggersDecided(TSTATUS)  
   /\ executeReaction(
          < REACTORID : Reactor | 
              reactions : REACTIONS1
                          reaction N when TRIGGERIDS --> OS do {RB}
                          REACTIONS2 >, N, TSTATUS, QUEUE) 
      => result(OBJECT, OUTPUTS, RESULT-QUEUE, CONST') .

---Note: the following equation cannot be used!
---(
 eq executeStep(GRAPH, NETWORK, QUEUE, INVOKED, CONST) 
  = networkQueueRxns(NETWORK, QUEUE, INVOKED, CONST) [owise] .
)---

 ceq executeStep(GRAPH, NETWORK, QUEUE, INVOKED, CONST) 
   = networkQueueRxns(NETWORK, QUEUE, INVOKED, CONST) 
  if noMoreReaction(GRAPH, none) .
endom
