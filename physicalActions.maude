*** Our model of physical actions using logical time:
---    Which seems quite general:
---    Each physical action has a period and a finite set of values
---      to choose from.
---    * At the end of each period, we choose nondeterministically
---      whether the action happens or not
---    * If the action happens, then we choose a value nondet
---      from the set of possible values.

in eventQueue.maude

omod PHYSICAL-ACTIONS is
  including EVENTS .

  --- The ENVIRONMENT represents all external actions,
  ---   namely, the physical actions:

  vars O O2 : Oid .
  var AI : ActionId .
  var RI : ReactorId .
  var P : TimeInf .
  var V : Value .
  var VS : ValueSet .
  var QUEUE : EQueue .
  var CONF : Configuration .
  var EVENT : Event .


  class Environment | physicalActions : Configuration .

  --- Dynamically, each physical action has:
  ---    * home address
  ---    * time left of period
  ---    * period
  ---    * range of values

  class PhysAct | leftOfPeriod : TimeInf,
		  period : TimeInf,
		  possibleValues : ValueSet .

  op _._ : ReactorId ActionId -> Oid [ctor] .
  --- names of physical actions!

  sort ValueSet .
  subsort Value < ValueSet .
  op noValue : -> ValueSet [ctor] .
  op _;_ : ValueSet ValueSet -> ValueSet [ctor assoc comm id: noValue] .

  rl [noAction] :
     < O : PhysAct | leftOfPeriod : 0, period : P > =>
     < O : PhysAct | leftOfPeriod : P > .

  rl [actionHappens] :
     < (RI . AI) : PhysAct | leftOfPeriod : 0, period : P,
                     possibleValues : (V ; VS) >
     =>
     < (RI . AI) : PhysAct | leftOfPeriod : P >
     scheduleAction(event(RI, AI, V)) .

  msg scheduleAction : Event -> Msg .

  eq < O : Environment | physicalActions :
                         CONF scheduleAction(EVENT) >
     < O2 : EventQueue | queue : QUEUE >
    =
     < O : Environment | physicalActions : CONF >
     < O2 : EventQueue | queue : schedule(EVENT, 0, QUEUE) > .

endom

