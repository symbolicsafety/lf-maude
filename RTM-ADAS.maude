*** This treats ADAS as is, WITH multiple triggers for the ADAS-controller.
*** We can now handle this case.

*** This is a version to run on Lepri's Maude 2.7 TCTL model checker for
***     good dold Real-Time Maude ...

*** Note that, as is, ADAS is an infinite-state system, since the frame variable
***  increase beyond any bound. We therefore change it to rest frame when it reaches 10.
*** Furthermore, the ADAS processor couldn't care less about these values ...

--- in rtm-tctl.maude

in dynamics

--- load REAL-TIME-MAUDE


(tomod ADAS-WITH-CAMERA is 
 including RUNTIME-APG .

 ops frame received brakesApplied requestStop counter1 counter2 counter3 : -> IVarId [ctor] .
 ops lidar camera adasProcessor dashboard pedal brakes : -> ReactorId [ctor] .
 op t : -> TimerId [ctor] .
 ops in in1 in2 out out1 out2 inAdas inPedal : -> IPortId [ctor] .
 op a : -> IActionId .
 op init : -> Configuration .
 
 eq init = 
    < lidar : Reactor | 
      inports : none,
      outports : < out : Port | value : [0] >, 
      state : (frame |-> [0]),
      timers : < t : Timer | offset : 0, period : 34 >, --- 0 and 34 originally
          --- change above values to 11 and 17 for error number 3 in p19
      actions : none,
      reactions : 
      reaction when t --> out do { if (frame === [10]) then (frame := [1]) else (frame := frame + [1]) fi ;
                                   (out <- frame)} >

   < camera : Reactor | 
      inports : none,
      outports : < out : Port | value : [0] >, 
      state : frame |-> [0],
      timers : < t : Timer | offset : 0, period : 17 >,	
      actions : none,
      reactions : 
      reaction when t --> out do { if (frame === [10]) then (frame := [1]) else (frame := frame + [1]) fi
                                  ; (out <- frame) } >


    < adasProcessor : Reactor | 
      inports : < in1 : Port | value : [0] >   < in2 : Port | value : [0] >,
      outports : < out1 : Port | value : [0] >
                 < out2 : Port | value : [0] >, 
      state : requestStop |-> [0],
      timers : none,
      actions : < a : LogicalAction | minDelay : 50, --- change to 51 for error 4
                               minSpacing : 0, 
                               policy : defer, 
                               payload : [0] >,
      reactions : 
         (reaction when (in1 ; in2) --> a do
	    { (requestStop := [1]) ;  schedule(a, [0], [0]) } )
         reaction when a --> out1 ; out2 do { 
          if requestStop === [1] then
              (out1 <- [1]) fi     *** CORRECT!
*** ERROR     (out2 <- [1])     --- ERROR CASE 1, page 19
         }
    >

    < dashboard : Reactor | 
        inports : < in : Port | value : [0] >,
        outports : none,
        state : received |-> [0],
        timers : none,
        actions : none,
        reactions : reaction when in do { received := in }       
    >
    
    < pedal : Reactor |
      inports : none,
      outports : < out : Port | value : [0] >,
      timers : none, 
      state : empty,
      actions : < a : PhysicalAction | 
                               minDelay : 0, 
                               minSpacing : 0, 
                               policy : defer, 
                               payload : [0] >,
      reactions : reaction when a --> out do { out <- [1] }
    >

    < brakes : Reactor |
      inports : < inAdas : Port | value : [0] > 
                < inPedal : Port | value : [0] >,
      outports : none,
      timers : none,
      actions : none,
      state : (brakesApplied |-> [0]),
      reactions : (reaction when inAdas do { (brakesApplied := inAdas)})
                  (reaction when inPedal do { (brakesApplied := inPedal) })

    >

    (camera : out --> adasProcessor : in2)
    (lidar : out --> adasProcessor : in1)     *** CORRECT; comment out line for
                                              ***   error 2 on p19
    (adasProcessor : out1 -- 5 --> brakes : inAdas)  --- change to 6 error 5
    (adasProcessor : out2 --> dashboard : in)
    pedal : out --> brakes : inPedal .
endtom)



(tomod TEST-ADAS is
  including ADAS-WITH-CAMERA .
  including DYNAMICS-WITHOUT-TICK .
  including SIMULATION-DYNAMICS .

  ops env queue : -> Oid [ctor] .

  op initSystem : -> GlobalSystem .
  eq initSystem =
     { < env : Environment |
           physicalActions : < (pedal . a) : PhysAct |
                                   leftOfPeriod : 5,
                                   period : 5,
                                   possibleValues : [69] : [71],
                                   timeNonDet : true > >
       addReactionIndices(init)
       < queue : EventQueue | queue : addInitialTimers(init, empty) >} .
endtom)



(tomod TCTL-CHECK-ADAS is
   including TEST-ADAS .
   including TCTL-MODEL-CHECKER  .

   ops brakeApplied stopRequested pedalPressed : -> Prop [ctor] .

   var REST : Configuration .  var N : Nat .  vars EQ1 EQ2 : EQueue .  var EVENTS : Events .
   var TAG : Tag .
   

   eq {REST <  brakes : Reactor | state : (brakesApplied |-> [ N ]) >} |= brakeApplied = (N == 1) .

   eq {REST <  adasProcessor : Reactor | state : (requestStop |-> [ N ]) >} |= stopRequested = (N == 1) .

   eq {REST  < queue : EventQueue | queue : (EQ1 :: ((event(pedal, a, [ N ]) EVENTS) at TAG) :: EQ2) >}
       |=  pedalPressed = true .

   eq {REST  < queue : EventQueue | queue : EQ2 >}
       |=  pedalPressed = false [owise] .
   

endtom)



(set tick det .)

(trew initSystem in time < 178 .)

(tsearch [1] initSystem  =>* {REST:Configuration
                < brakes : Reactor | state : (brakesApplied |-> [1]) ; RS:ReactorState,
		                     AS:AttributeSet >} in time <= 10 .)

(tsearch [1] initSystem  =>* {REST:Configuration
                < queue : EventQueue | queue : (EQ1 ::
		((event(pedal, a, [ N ]) EVENTS) at TAG) :: EQ2) >} in time <= 10 .)



--- we will always apply the brakes within time 55:
(mc-tctl initSystem |= AF[<= than 55] brakeApplied .)


***(   in  12 seconds ...
Check
mc-tctl_|=_. initSystem |= AF[<= than 55] brakeApplied .
in TCTL-CHECK-ADAS with mode deterministic time increase


Checking equivalent property:
mc-tctl_|=_. initSystem |= not (E not brakeApplied U[o 55,INF o] tt) .

Property satisfied
)***




--- When requestStop is 1 then within time 55 the brakeApplied

--- (mc-tctl initSystem |= AG (stopRequested implies (AF[<= than 55] brakeApplied)) .)

***(  Output:
rewrites: 1544021 in 13496ms cpu (13718ms real) (114399 rewrites/second)

Check
mc-tctl_|=_. initSystem |= AG (stopRequested implies AF[<= than 55] brakeApplied) .
in TCTL-CHECK-ADAS with mode deterministic time increase


Checking equivalent property:
mc-tctl_|=_. initSystem |= not (E tt U[c 0,INF o] stopRequested and (E not brakeApplied U[o 55,INF o] tt)) .

Property satisfied
)***

*** Property not satisfied for bound 54 ...


*** What we are really interested in in this nondeterministic model is
***   that each time the driver presses the pedal, within time 0, the brakes will
***   apply.

--- In our interpreter, when a physical action happens, the even is entered into
---    the event queue with delay 0.

(mc-tctl initSystem |=   AG  (pedalPressed implies AF[<= than 0] brakeApplied) .)


***(   Result:

rewrites: 1538850 in 13938ms cpu (14090ms real) (110403 rewrites/second)

Check
mc-tctl_|=_. initSystem |= AG (pedalPressed implies AF[<= than 0] brakeApplied) .
in TCTL-CHECK-ADAS with mode deterministic time increase


Checking equivalent property:
mc-tctl_|=_. initSystem |= not (E tt U[c 0,INF o] pedalPressed and (E not brakeApplied U[o 0,INF o] tt)) .

Property satisfied
)***


