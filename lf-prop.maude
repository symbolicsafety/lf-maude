omod LF-PROP is
  pr SATISFACTION .
  pr UNBOUNDED-AND-BOUNDED-ANALYSIS-DYNAMICS .

  subsort ClockedSystem < State .

  var REST INPORTS : Configuration .
  var REACTORID : ReactorId .
  var AT : ActionTrigger .
  var VAR : VarId .
  var VAL VAL' : Value .
  var RVAR : RVarId .
  var RVAL RVAL' : Value .
  var RS : ReactorState .
  var T : Time .
  var TI : TimeInf .
  var O : Oid .
  var PI : PortId .
  var RPI : RPortId .
  var RID : ReactionId .
  var RIDS : ReactionIdSet .
  vars EQ1 EQ2 : EQueue .
  var EVENT : Event .
  var EVENTS : Events .
  var TAG : Tag .

  --- generic atomic proposition:

  op _in_==_ : VarId ReactorId Value -> Prop [ctor] .
  op _in_!=_ : VarId ReactorId Value -> Prop [ctor] .
  op _in_<=_ : RVarId ReactorId RatValue -> Prop [ctor] .
  op _in_<_  : RVarId ReactorId RatValue -> Prop [ctor] .
  op _in_>=_ : RVarId ReactorId RatValue -> Prop [ctor] .
  op _in_>_  : RVarId ReactorId RatValue -> Prop [ctor] .

  eq {REST < REACTORID : Reactor | state : (VAR |-> VAL) ; RS >}
     |= VAR in REACTORID == VAL = true . 

  eq {REST < REACTORID : Reactor | state : (VAR |-> VAL) ; RS >}
     |= VAR in REACTORID != VAL' = (VAL =/= VAL') .

  eq {REST < REACTORID : Reactor | state : (RVAR |-> RVAL) ; RS >}
     |= RVAR in REACTORID <= RVAL' = (RVAL <= RVAL') == [true] . 

  eq {REST < REACTORID : Reactor | state : (RVAR |-> RVAL) ; RS >}
     |= RVAR in REACTORID < RVAL' = (RVAL < RVAL') == [true] . 

  eq {REST < REACTORID : Reactor | state : (RVAR |-> RVAL) ; RS >}
     |= RVAR in REACTORID >= RVAL' = (RVAL >= RVAL') == [true] . 

  eq {REST < REACTORID : Reactor | state : (RVAR |-> RVAL) ; RS >}
     |= RVAR in REACTORID > RVAL' = (RVAL > RVAL') == [true] . 

  op _in_==_ : PortId ReactorId Value -> Prop [ctor] .
  op _in_!=_ : PortId ReactorId Value -> Prop [ctor] .
  op _in_<=_ : RPortId ReactorId RatValue -> Prop [ctor] .
  op _in_<_  : RPortId ReactorId RatValue -> Prop [ctor] .
  op _in_>=_ : RPortId ReactorId RatValue -> Prop [ctor] .
  op _in_>_  : RPortId ReactorId RatValue -> Prop [ctor] .

  eq {REST < REACTORID : Reactor | inports : < PI : Port | value : VAL > INPORTS >}
     |= PI in REACTORID == VAL = true . 

  eq {REST < REACTORID : Reactor | inports : < PI : Port | value : VAL > INPORTS >}
     |= PI in REACTORID != VAL' = (VAL =/= VAL') . 

  eq {REST < REACTORID : Reactor | inports : < RPI : Port | value : RVAL > INPORTS >}
     |= RPI in REACTORID <= RVAL' = (RVAL <= RVAL') == [true] . 

  eq {REST < REACTORID : Reactor | inports : < RPI : Port | value : RVAL > INPORTS >}
     |= RPI in REACTORID < RVAL' = (RVAL < RVAL') == [true] . 

  eq {REST < REACTORID : Reactor | inports : < RPI : Port | value : RVAL > INPORTS >}
     |= RPI in REACTORID >= RVAL' = (RVAL >= RVAL') == [true] . 

  eq {REST < REACTORID : Reactor | inports : < RPI : Port | value : RVAL > INPORTS >}
     |= RPI in REACTORID > RVAL' = (RVAL > RVAL') == [true] . 

  --- An event is in the event queue:
  op _inQueue : Event -> Prop [ctor] .

  eq {REST
      < O : EventQueue | queue : (EQ1 :: ((EVENT EVENTS) at TAG) :: EQ2) >}
     |=  EVENT inQueue = true .

  op event(_,_)inQueue : ReactorId ActionTrigger -> Prop [ctor] .

  eq {REST
      < O : EventQueue | queue : (EQ1 :: ((event(REACTORID,AT,VAL,[true]) EVENTS) at TAG) :: EQ2) >}
     |=  event(REACTORID, AT) inQueue = true .


  --- NEW Feb25: a reaction is/was invoken in this/last step:
  op _invoked : ReactionId -> Prop [ctor] .

  eq {REST
      < O : Invoked | reactions : (RID ; RIDS) >}
     |=  RID invoked = true .

  --- Default false case
  eq STATE:State |= P:Prop = false [owise] .

  --- Extend to timed/time-bounded cases
  ceq STATE:State   in time TI |= P:Prop = true if STATE:State |= P:Prop .
  ceq STATE:State timeBound TI |= P:Prop = true if STATE:State |= P:Prop .

endom


fmod BOOLEAN-FORMULA is
  protecting BOOL .
  sort BoolFormula .

  ops True False : -> BoolFormula [ctor format (g o)] .
  op ~_ : BoolFormula -> BoolFormula [ctor prec 53 format (r o d)] .
  op _/\_ : BoolFormula BoolFormula -> BoolFormula [comm ctor gather (E e) prec 55 format (d r o d)] .
  op _\/_ : BoolFormula BoolFormula -> BoolFormula [comm ctor gather (E e) prec 59 format (d r o d)] .

  op _->_ : BoolFormula BoolFormula -> BoolFormula [gather (e E) prec 65 format (d r o d)] .
  op _<->_ : BoolFormula BoolFormula -> BoolFormula [prec 65 format (d r o d)] .

  vars F G : BoolFormula .

  eq F -> G = ~ F \/ G .
  eq F <-> G = (F -> G) /\ (G -> F) .

  *** negative normal form
  eq ~ True = False .
  eq ~ False = True .
  eq ~ ~ F = F .
  eq ~ (F \/ G) = ~ F /\ ~ G .
  eq ~ (F /\ G) = ~ F \/ ~ G .
endfm


fmod SEARCH-GOAL is
  pr SATISFACTION .
  pr BOOLEAN-FORMULA .
  
  subsort Prop < BoolFormula .
  op _|=_ : State BoolFormula ~> Bool [frozen] .
  
  var STATE : State .
  vars F G : BoolFormula .

  eq STATE |= True  = true .
  eq STATE |= False = false .

  eq STATE |= (~ F) = not (STATE |= F) .
  eq STATE |= (F /\ G) = (STATE |= F) and (STATE |= G) .
  eq STATE |= (F \/ G) = (STATE |= F) or  (STATE |= G) .
endfm


omod LF-OUTPUT-REPR is
  including LF-PROP .
  including UNBOUNDED-AND-BOUNDED-ANALYSIS-DYNAMICS .

--- simplified counter example information
  sort OutputItem .
  op time:_ : Time -> OutputItem [ctor format(b o d)] .
  op invoked:_ : ReactionIdSet -> OutputItem [ctor prec 124 format(b o d)] .
  op queue:_ : EQueue -> OutputItem [ctor prec 124 format(b o d)] .
  op inports:_ : Map{Oid,Value} -> OutputItem [ctor prec 124 format(b o d)] .
  op state:_ : ReactorState -> OutputItem [ctor prec 124 format(b o d)] .
  op _:`[_`] : ReactorId OutputItemSet -> OutputItem [ctor format(r o d n++i d --)] .

  sort OutputItemSet .
  subsort OutputItem < OutputItemSet .
  op none : -> OutputItemSet [ctor] .
  op __ : OutputItemSet OutputItemSet -> OutputItemSet [ctor comm assoc id: none format(d ni d) prec 126] .

  sort Map{Oid,Value} .
  subsort ReactorState < Map{Oid,Value} .
  op _|->_ : Oid Value -> Map{Oid,Value} [ctor] .
  op _;_ : Map{Oid,Value} Map{Oid,Value} -> Map{Oid,Value} [ctor ditto] .

  var O : Oid .
  var RIS : ReactionIdSet .
  var EQ : EQueue .
  var PORTS REST : Configuration .
  var VALUATION : ReactorState .
  var VAL : Value .
  var T : Time .
  var TI : TimeInf .
  var OIS : OutputItemSet .

--- simplify
  op simplify : ClockedSystem ~> OutputItemSet .
  eq simplify({REST} in time T  timeBound TI) = (time: T) simplify(REST) .
  eq simplify({REST} in time INF timeBound TI) = simplify(REST) .
  eq simplify({REST} timeBound TI) = simplify(REST) .
  eq simplify({REST} in time T) = (time: T) simplify(REST) .
  eq simplify({REST} in time INF) = simplify(REST) .
  eq simplify({REST}) = simplify(REST) .

  op simplify : Configuration ~> OutputItemSet .
  eq simplify(< O : Invoked | reactions : RIS > REST) 
   = (invoked: RIS) simplify(REST) .
  eq simplify(< O : EventQueue | queue : EQ > REST) 
   = (queue: EQ) simplify(REST) .
  eq simplify(< O : Reactor | inports : PORTS, state : VALUATION > REST)
   = (O : [inports: simplifyPorts(PORTS) state: VALUATION]) simplify(REST) .
  eq simplify(REST) = none [owise] .

  op simplifyPorts : Configuration ~> Map{Oid,Value} .
  eq simplifyPorts(< O : Port | value : VAL > PORTS)
   = (O |-> VAL) ; simplifyPorts(PORTS) .
  eq simplifyPorts(none) = empty .
endom



omod LF-OUTPUT-COUNTEREXAMPLE is
  including LF-OUTPUT-REPR .
  including MODEL-CHECKER .

  var STATE : State .
  var RN : RuleName .

  --- new counterexample transition
  op `{_`}===[_]===> : OutputItemSet RuleName -> Transition [ctor format(n ++i d n -- d d d d)] .

  eq {STATE, RN} = {simplify(STATE)}===[RN]===> .
endom

