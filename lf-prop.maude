omod LF-PROP is
  pr SATISFACTION .
  pr UNBOUNDED-AND-BOUNDED-ANALYSIS-DYNAMICS .

  subsort ClockedSystem < State .

  var REST INPORTS : Configuration .
  var REACTORID : ReactorId .
  var VAR : VarId .
  var VAL VAL' : Value .
  var RVAR : RVarId .
  var RVAL RVAL' : Value .
  var RS : ReactorState .
  var T : Time .
  var O : Oid .
  var PI : PortId .
  var RPI : RPortId .
  var RID : ReactionId .
  var RIDS : ReactionIdSet .
  vars EQ1 EQ2 : EQueue .
  var EVENT : Event .
  var EVENTS : Events .
  var TAG : Tag .

  --- generic atomic proposition:

  op _in_==_ : VarId ReactorId Value -> Prop [ctor] .
  op _in_!=_ : VarId ReactorId Value -> Prop [ctor] .
  op _in_<=_ : RVarId ReactorId RatValue -> Prop [ctor] .
  op _in_<_  : RVarId ReactorId RatValue -> Prop [ctor] .
  op _in_>=_ : RVarId ReactorId RatValue -> Prop [ctor] .
  op _in_>_  : RVarId ReactorId RatValue -> Prop [ctor] .

  eq {REST < REACTORID : Reactor | state : (VAR |-> VAL) ; RS >}
     |= VAR in REACTORID == VAL = true . 

  eq {REST < REACTORID : Reactor | state : (VAR |-> VAL) ; RS >}
     |= VAR in REACTORID != VAL' = (VAL =/= VAL') .

  eq {REST < REACTORID : Reactor | state : (RVAR |-> RVAL) ; RS >}
     |= RVAR in REACTORID <= RVAL' = (RVAL <= RVAL') == [true] . 

  eq {REST < REACTORID : Reactor | state : (RVAR |-> RVAL) ; RS >}
     |= RVAR in REACTORID < RVAL' = (RVAL < RVAL') == [true] . 

  eq {REST < REACTORID : Reactor | state : (RVAR |-> RVAL) ; RS >}
     |= RVAR in REACTORID >= RVAL' = (RVAL >= RVAL') == [true] . 

  eq {REST < REACTORID : Reactor | state : (RVAR |-> RVAL) ; RS >}
     |= RVAR in REACTORID > RVAL' = (RVAL > RVAL') == [true] . 

  op _in_==_ : PortId ReactorId Value -> Prop [ctor] .
  op _in_!=_ : PortId ReactorId Value -> Prop [ctor] .
  op _in_<=_ : RPortId ReactorId RatValue -> Prop [ctor] .
  op _in_<_  : RPortId ReactorId RatValue -> Prop [ctor] .
  op _in_>=_ : RPortId ReactorId RatValue -> Prop [ctor] .
  op _in_>_  : RPortId ReactorId RatValue -> Prop [ctor] .

  eq {REST < REACTORID : Reactor | inports : < PI : Port | value : VAL > INPORTS >}
     |= PI in REACTORID == VAL = true . 

  eq {REST < REACTORID : Reactor | inports : < PI : Port | value : VAL > INPORTS >}
     |= PI in REACTORID != VAL' = (VAL =/= VAL') . 

  eq {REST < REACTORID : Reactor | inports : < RPI : Port | value : RVAL > INPORTS >}
     |= RPI in REACTORID <= RVAL' = (RVAL <= RVAL') == [true] . 

  eq {REST < REACTORID : Reactor | inports : < RPI : Port | value : RVAL > INPORTS >}
     |= RPI in REACTORID < RVAL' = (RVAL < RVAL') == [true] . 

  eq {REST < REACTORID : Reactor | inports : < RPI : Port | value : RVAL > INPORTS >}
     |= RPI in REACTORID >= RVAL' = (RVAL >= RVAL') == [true] . 

  eq {REST < REACTORID : Reactor | inports : < RPI : Port | value : RVAL > INPORTS >}
     |= RPI in REACTORID > RVAL' = (RVAL > RVAL') == [true] . 

  --- An event is in the event queue:
  op _inQueue : Event -> Prop [ctor] .

  eq {REST
      < O : EventQueue | queue : (EQ1 :: ((EVENT EVENTS) at TAG) :: EQ2) >}
     |=  EVENT inQueue = true .

  --- NEW Feb25: a reaction is/was invoken in this/last step:
  op _invoked : ReactionId -> Prop [ctor] .

  eq {REST
      < O : Invoked | reactions : (RID ; RIDS) >}
     |=  RID invoked = true .

  --- Extend to timed/time-bounded cases
  ceq STATE:State   in time T |= P:Prop = true if STATE:State |= P:Prop .
  ceq STATE:State timeBound T |= P:Prop = true if STATE:State |= P:Prop .
endom


fmod BOOLEAN-FORMULA is
  protecting BOOL .
  sort BoolFormula .

  ops True False : -> BoolFormula [ctor format (g o)] .
  op ~_ : BoolFormula -> BoolFormula [ctor prec 53 format (r o d)] .
  op _/\_ : BoolFormula BoolFormula -> BoolFormula [comm ctor gather (E e) prec 55 format (d r o d)] .
  op _\/_ : BoolFormula BoolFormula -> BoolFormula [comm ctor gather (E e) prec 59 format (d r o d)] .

  op _->_ : BoolFormula BoolFormula -> BoolFormula [gather (e E) prec 65 format (d r o d)] .
  op _<->_ : BoolFormula BoolFormula -> BoolFormula [prec 65 format (d r o d)] .

  vars F G : BoolFormula .

  eq F -> G = ~ F \/ G .
  eq F <-> G = (F -> G) /\ (G -> F) .

  *** negative normal form
  eq ~ True = False .
  eq ~ False = True .
  eq ~ ~ F = F .
  eq ~ (F \/ G) = ~ F /\ ~ G .
  eq ~ (F /\ G) = ~ F \/ ~ G .
endfm


fmod SEARCH-GOAL is
  pr SATISFACTION .
  pr BOOLEAN-FORMULA .
  
  subsort Prop < BoolFormula .
  op _|=_ : State BoolFormula ~> Bool [frozen] .
  
  var STATE : State .
  vars F G : BoolFormula .

  eq STATE |= True  = true .
  eq STATE |= False = false .

  eq STATE |= (~ F) = not (STATE |= F) .
  eq STATE |= (F /\ G) = (STATE |= F) and (STATE |= G) .
  eq STATE |= (F \/ G) = (STATE |= F) or  (STATE |= G) .
endfm


