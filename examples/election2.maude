
omod ELECTION2 is 
  including LF-REPR .
  protecting NAT-LF-TIME .
  protecting RUNTIME-APG .

  ops id elected : -> RVarId [ctor] .
  ops node0 node1 node2 : -> ReactorId [ctor] .
  ops in out : -> RPortId [ctor] .
  ops startup : -> RActionId [ctor] .
  op init : -> Configuration .

  eq init
   = < node0 : Reactor |
          inports : < in : Port | value : [0] >,
	      outports : < out : Port | value : [0] >,
	      state : (id |-> [0]) ; (elected |-> [0]),
	      timers : none,
	      actions : < startup : LogicalAction | minDelay : 0, 
                                                minSpacing : 0, 
                                                policy : defer, 
                                                payload : [0] >,
	      reactions :
	        (reaction when startup --> out do { (id := [0]); (out <- id)})
             reaction when in --> out do {if (in > id) then out <- in 
                else if (in === id) then elected := [1] fi fi} 
      >
            
      < node1 : Reactor |
          inports : < in : Port | value : [0] >,
	      outports : < out : Port | value : [0] >,
	      state : (id |-> [0]) ; (elected |-> [0]),
	      timers : none,
	      actions : < startup : LogicalAction | minDelay : 0, 
                                                minSpacing : 0, 
                                                policy : defer, 
                                                payload : [0] >,
	      reactions :
	        (reaction when startup --> out do { (id := [1]); (out <- id)})
             reaction when in --> out do {if (in > id) then out <- in 
                else if (in === id) then elected := [1] fi fi} 
      > 
            
      < node2 : Reactor |
          inports : < in : Port | value : [0] >,
	      outports : < out : Port | value : [0] >,
	      state : (id |-> [0]) ; (elected |-> [0]),
	      timers : none,
	      actions : < startup : LogicalAction | minDelay : 0, 
                                                minSpacing : 0, 
                                                policy : defer, 
                                                payload : [0] >,
	      reactions :
	        (reaction when startup --> out do { (id := [2]); (out <- id)})
             reaction when in --> out do {if (in > id) then out <- in 
                else if (in === id) then elected := [1] fi fi} 
      > 
      
      (node0 : out -- 10 --> node1 : in)
      (node1 : out -- 10 --> node2 : in)
       node2 : out -- 10 --> node0 : in .
endom

omod TEST-ELECTION2 is
  including ELECTION2 .
  including DYNAMICS-WITHOUT-TICK .

  ops env queue rxns : -> Oid [ctor] .

  op initSystem : -> GlobalSystem .
  eq initSystem =
      {< env : Environment | physicalActions : none >
       addReactionIndices(init)
       < queue : EventQueue | queue : addStartup(startup, init, empty) >
       < rxns : Invoked | reactions : none >} .
endom

***( the main property in the LF repository is

spec="F[0, 20 msec]((Election2_i0_elected + Election2_i1_elected + Election2_i2_elected) == 1)", expect=false

It should be true in 30 msec

)***

omod TIME-BOUNDED-ELECTION2 is
  including TEST-ELECTION2 .
  including TIME-BOUNDED-DYNAMICS .
  eq timeBound = 20 .
endom  

in model-checker.maude

omod MODEL-CHECK-ELECTION2 is
  including MODEL-CHECKER .
  including TIME-BOUNDED-ELECTION2 .
  subsort ClockedSystem < State .

  var REST : Configuration .
  vars N0 N1 N2 SUM : Nat .
  vars RS0 RS1 RS2 : ReactorState .
  var T : Time .

  op sumIs_ : Nat -> Prop [ctor] .
  eq {REST  < node0 : Reactor | state : (elected |-> [ N0 ]) ; RS0 >
            < node1 : Reactor | state : (elected |-> [ N1 ]) ; RS1 >
            < node2 : Reactor | state : (elected |-> [ N2 ]) ; RS2 >
      } in time T
      |= sumIs SUM = N0 + N1 + N2 == SUM .
endom

red modelCheck(initSystem in time 0, <> (sumIs 1)) .

***(    Result:
reduce in MODEL-CHECK-ELECTION2 : modelCheck(initSystem in time 0, <> sumIs 1) .
rewrites: 452 in 1ms cpu (0ms real) (452000 rewrites/second)
result ModelCheckResult: counterexample(... {{< node0 : Reactor | inports : < in : Port | value : [2] >, outports : < out : Port | value : [2] >, state : ((id |-> [0]) ; elected |-> [0]), reactions : (reaction 1 when startup --> out do{(id := [0]) ; out <- id} reaction 2 when in --> out do{if in > id then out <- in else if in === id then elected := [1] fi fi}), timers : none, actions : < startup : LogicalAction | minDelay : 0, minSpacing : 0, policy : defer, payload : [0] > > < node1 : Reactor | inports : < in : Port | value : [2] >, outports : < out : Port | value : [2] >, state : ((id |-> [1]) ; elected |-> [0]), reactions : (reaction 1 when startup --> out do{(id := [1]) ; out <- id} reaction 2 when in --> out do{if in > id then out <- in else if in === id then elected := [1] fi fi}), timers : none, actions : < startup : LogicalAction | minDelay : 0, minSpacing : 0, policy : defer, payload : [0] > > < node2 : Reactor | inports : < in : Port | value : [1] >, outports : < out : Port | value : [2] >, state : ((id |-> [2]) ; elected |-> [0]), reactions : (reaction 1 when startup --> out do{(id := [2]) ; out <- id} reaction 2 when in --> out do{if in > id then out <- in else if in === id then elected := [1] fi fi}), timers : none, actions : < startup : LogicalAction | minDelay : 0, minSpacing : 0, policy : defer, payload : [0] > > < env : Environment | physicalActions : none > < queue : EventQueue | queue : event(node2, in, [2]) at tag(10, 0) > < rxns : Invoked | reactions : (node1 . 2) > (node0 : out -- 10 --> node1 : in) (node1 : out -- 10 --> node2 : in) node2 : out -- 10 --> node0 : in}  in time 20,deadlock})

--- When timeBound = 30:
reduce in MODEL-CHECK-ELECTION2 : modelCheck(initSystem in time 0, <> sumIs 1) .
rewrites: 520 in 1ms cpu (0ms real) (520000 rewrites/second)
result Bool: true
)***
