---(****************************
 * Auto-generated Maude model *
 ******************************)---
omod TRAINDOORFEEDBACK is
    including LF-REPR .
    protecting LF-VALUE-TIME .

    op TrainDoorFeedback : -> ReactorId [ctor] .
    op c : -> ReactorId [ctor] .
    op t : -> ReactorId [ctor] .
    op d : -> ReactorId [ctor] .
    op d2 : -> ReactorId [ctor] .
    op s : -> ReactorId [ctor] .
    op t.sv.received : -> RVarId [ctor] .
    op d.sv.received : -> RVarId [ctor] .
    op d2.sv.received : -> RVarId [ctor] .
    op s.sv.sum : -> RVarId [ctor] .
    op c.in.in : -> RPortId [ctor] .
    op c.out.out1 : -> RPortId [ctor] .
    op c.out.out2 : -> RPortId [ctor] .
    op c.out.out3 : -> RPortId [ctor] .
    op t.in.in : -> RPortId [ctor] .
    op t.out.out : -> RPortId [ctor] .
    op d.in.in : -> RPortId [ctor] .
    op d.out.out : -> RPortId [ctor] .
    op d2.in.in : -> RPortId [ctor] .
    op d2.out.out : -> RPortId [ctor] .
    op s.in.in1 : -> RPortId [ctor] .
    op s.in.in2 : -> RPortId [ctor] .
    op s.in.in3 : -> RPortId [ctor] .
    op s.out.out : -> RPortId [ctor] .
    op c.la.another : -> RActionId [ctor] .
    op startup : -> RActionId [ctor] .
    op init : -> Configuration .
    
    eq init = 
        < c : Reactor |
            inports : 
                < c.in.in : Port | value : [0] >,
            outports : 
                < c.out.out1 : Port | value : [0] >
                < c.out.out2 : Port | value : [0] >
                < c.out.out3 : Port | value : [0] >,
            state : empty,
            timers : none,
            actions : 
                < c.la.another : LogicalAction | minDelay : 5000000, minSpacing : 0, policy : defer, payload : [0] >
                < startup : LogicalAction | minDelay : 0, minSpacing : 0, policy : defer, payload : [0] >,
            reactions : 
                (reaction when (startup ; c.la.another) --> (c.out.out1 ; c.out.out2 ; c.out.out3) do {
                    (c.out.out1 <- [1]) ;
                    (c.out.out2 <- [2]) ;
                    (c.out.out3 <- [3])
                })
                (reaction when (c.in.in) --> (c.la.another) do {
                    schedule(c.la.another, [0], [0])
                })
        >
        < t : Reactor |
            inports : 
                < t.in.in : Port | value : [0] >,
            outports : 
                < t.out.out : Port | value : [0] >,
            state : 
                ( t.sv.received |-> [0] ),
            timers : none,
            actions : none,
            reactions : 
                (reaction when (t.in.in) --> (t.out.out) do {
                    (t.sv.received := t.in.in) ;
                    (t.out.out <- t.sv.received)
                })
        >
        < d : Reactor |
            inports : 
                < d.in.in : Port | value : [0] >,
            outports : 
                < d.out.out : Port | value : [0] >,
            state : 
                ( d.sv.received |-> [0] ),
            timers : none,
            actions : none,
            reactions : 
                (reaction when (d.in.in) --> (d.out.out) do {
                    (d.sv.received := d.in.in) ;
                    (d.out.out <- d.sv.received)
                })
        >
        < d2 : Reactor |
            inports : 
                < d2.in.in : Port | value : [0] >,
            outports : 
                < d2.out.out : Port | value : [0] >,
            state : 
                ( d2.sv.received |-> [0] ),
            timers : none,
            actions : none,
            reactions : 
                (reaction when (d2.in.in) --> (d2.out.out) do {
                    (d2.sv.received := d2.in.in) ;
                    (d2.out.out <- d2.sv.received)
                })
        >
        < s : Reactor |
            inports : 
                < s.in.in1 : Port | value : [0] >
                < s.in.in2 : Port | value : [0] >
                < s.in.in3 : Port | value : [0] >,
            outports : 
                < s.out.out : Port | value : [0] >,
            state : 
                ( s.sv.sum |-> [0] ),
            timers : none,
            actions : none,
            reactions : 
                (reaction when (s.in.in1 ; s.in.in2 ; s.in.in3) --> (s.out.out) do {
                    (s.sv.sum := (s.in.in1 + s.in.in2)) ;
                    (s.out.out <- s.sv.sum)
                })
        >
    (c : c.out.out1 -- 1000000 --> t : t.in.in)
    (c : c.out.out2 -- 1000000 --> d : d.in.in)
    (c : c.out.out3 -- 1000000 --> d2 : d2.in.in)
    (t : t.out.out --> s : s.in.in1)
    (d : d.out.out --> s : s.in.in2)
    (d2 : d2.out.out --> s : s.in.in3)
    (s : s.out.out --> c : c.in.in)
    .
endom

omod TEST-TRAINDOORFEEDBACK is
    including TRAINDOORFEEDBACK .
    including DYNAMICS-WITHOUT-TICK .

    ops env queue rxns : -> Oid [ctor] .

    op initSystem : -> GlobalSystem .
    eq initSystem =
        { < env : Environment |
            physicalActions : none
             > 
            addReactionIndices(init)
            < queue : EventQueue | queue : 
            addStartup(startup, init, empty) >
            < rxns : Invoked | reactions : none >} .
endom

omod ANALYSIS-TRAINDOORFEEDBACK is
    including TEST-TRAINDOORFEEDBACK .
    including LF-PROP-EXT .
    including SEARCH-GOAL .
endom

omod MODELCHECKER-TRAINDOORFEEDBACK is
    including TEST-TRAINDOORFEEDBACK .
    including LF-OUTPUT-COUNTEREXAMPLE .
    including LF-PROP-EXT .
    including MODEL-CHECKER .
endom

omod SIMULATION-TRAINDOORFEEDBACK is
    including TEST-TRAINDOORFEEDBACK .
    including TIMED-SIMULATION-DYNAMICS .
endom

red in MODELCHECKER-TRAINDOORFEEDBACK : modelCheck(initSystem timeBound 1000000 , (((((~ (((((t . 1) invoked ))))))) U (((((d . 1) invoked )))))) ) .

quit
